---
output:
  html_document: default
  pdf_document: default
---

<center> <h1>Analytics en Redes sociales - Fase 3</h1> </center>

<center> <h3> Daniel Florez - Jeison Díaz - Juan Guerrero - Wilson Lopez</h3> </center>

<br />

#### Cargar las librerías

Importar las librerías a usar.
```{r,warning=FALSE,message=FALSE}
library(rjson)
library(tidyverse)
library(sna)
library(igraph)
library(jsonlite)
library(purrr)
library(data.table)
library(readxl)
library(dplyr)
```

Cargar los datos iniciales de arcos y nodos
```{r,warning=FALSE,message=FALSE}
# Cargando los datos de arcos y nodos
ubicacion_edges<-"Arcos.xlsx"
arcos<-read_excel(ubicacion_edges)

colnames(arcos)<-c("from","to")

nodos_file <-"Nodos.xlsx"
nodos <- read_excel(nodos_file)

arcos <- arcos[!is.na(arcos$from), ]

nodos <- nodos %>%
  filter(Id %in% arcos$from)

arcos <- arcos %>%
  filter(to %in% nodos$Id & from %in% nodos$Id)

n_grafo <- graph_from_edgelist(as.matrix(arcos))

numero_nodos <- vcount(n_grafo)
numero_arcos <- ecount(n_grafo)

print(paste("Número de nodos:", numero_nodos))
print(paste("Número de arcos:", numero_arcos))


```

Como puede observar en la red, esta se compone de 649 nodos y 829 arcos.

#### Modelo QAP

```{r,warning=FALSE,message=FALSE}
#Escriba su código aquí
y<- as.matrix(as_adjacency_matrix(n_grafo))

grado_total <- degree(n_grafo, mode = "all") 

grado_total <- (grado_total-min(grado_total))/(max(grado_total)-min(grado_total))

x1 <- matrix(NA, nrow = nrow(y), ncol = nrow(y))

# Asignar nombres o índices de los nodos a las filas y columnas de x1
rownames(x1) <- rownames(y)
colnames(x1) <- colnames(y)

# Llenar la matriz x1 con la similitud entre los grados normalizados de los nodos
for (i in 1:nrow(y)) {
  for (j in 1:nrow(y)) {
    x1[i, j] <- 1 - abs(grado_total[i] - grado_total[j])
  }
}

bet <- betweenness(n_grafo)

bet <- (bet-min(bet))/(max(bet)-min(bet))

x2 <- matrix(NA, nrow = nrow(y), ncol = nrow(y))

# Asignar nombres o índices de los nodos a las filas y columnas de x1
rownames(x2) <- rownames(y)
colnames(x2) <- colnames(y)

# Llenar la matriz x1 con la similitud entre los grados normalizados de los nodos
for (i in 1:nrow(y)) {
  for (j in 1:nrow(y)) {
    x2[i, j] <- 1 - abs(bet[i] - bet[j])
  }
}

pr <- page_rank(n_grafo)$vector

pr <- (pr-min(pr))/(max(pr)-min(pr))

x3 <- matrix(NA, nrow = nrow(y), ncol = nrow(y))

# Asignar nombres o índices de los nodos a las filas y columnas de x1
rownames(x3) <- rownames(y)
colnames(x3) <- colnames(y)

# Llenar la matriz x1 con la similitud entre los grados normalizados de los nodos
for (i in 1:nrow(y)) {
  for (j in 1:nrow(y)) {
    x3[i, j] <- 1 - abs(pr[i] - pr[j])
  }
}
```

Finalmente, estimemos la regresión QAP con estas dos matrices.

```{r,warning=FALSE,message=FALSE}
# Estimar la regresión QAP con la función netlogit. Debido a que son varios nodos, reduciremos la cantidad de repeticiones a realizar.
qap_fit <-netlogit(y,list(x1,x2,x3),rep = 10) 

# Ver los resultados esperados al finalizar las matrices calculadas
summary(qap_fit)
```
Se puede evidenciar que los atributos betweeness y Page Rank son significativos.