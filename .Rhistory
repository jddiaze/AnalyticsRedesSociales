library(rjson)
library(tidyverse)
library(sna)
library(igraph)
library(jsonlite)
library(purrr)
library(data.table)
library(readxl)
library(dplyr)
# Cargando los datos de arcos y nodos
ubicacion_edges<-"Arcos.xlsx"
arcos<-read_excel(ubicacion_edges)
colnames(arcos)<-c("from","to")
nodos_file <-"Nodos.xlsx"
nodos <- read_excel(nodos_file)
arcos <- arcos[!is.na(arcos$from), ]
nodos <- nodos %>%
filter(Id %in% arcos$from)
arcos <- arcos %>%
filter(to %in% nodos$Id & from %in% nodos$Id)
n_grafo <- graph_from_edgelist(as.matrix(arcos))
numero_nodos <- vcount(n_grafo)
numero_arcos <- ecount(n_grafo)
print(paste("Número de nodos:", numero_nodos))
print(paste("Número de arcos:", numero_arcos))
#Escriba su código aquí
y<- as.matrix(as_adjacency_matrix(n_grafo))
#Escriba su código aquí
y<- as.matrix(as_adjacency_matrix(n_grafo))
grado_total <- degree(n_grafo, mode = "all")
grado_total <- (grado_total-min(grado_total))/(max(grado_total)-min(grado_total))
x1 <- matrix(NA, nrow = nrow(y), ncol = nrow(y))
# Asignar nombres o índices de los nodos a las filas y columnas de x1
rownames(x1) <- rownames(y)
colnames(x1) <- colnames(y)
x1
View(x1)
View(x1)
View(y)
View(y)
# Llenar la matriz x1 con la similitud entre los grados normalizados de los nodos
for (i in 1:nrow(y)) {
for (j in 1:nrow(y)) {
x1[i, j] <- 1 - abs(grado_total[i] - grado_total[j])
}
}
View(x1)
View(x1)
# Estimar la regresión QAP con la función netlogit. Debido a que son varios nodos, reduciremos la cantidad de repeticiones a realizar.
qap_fit <-netlogit(y,list(x1),rep = 10)
# Ver los resultados esperados al finalizar las matrices calculadas
summary(qap_fit)
bet <- betweenness(n_grafo)
bet <- (bet-min(bet))/(max(bet)-min(bet))
x2 <- matrix(NA, nrow = nrow(y), ncol = nrow(y))
# Asignar nombres o índices de los nodos a las filas y columnas de x1
rownames(x2) <- rownames(y)
colnames(x2) <- colnames(y)
x2 <- matrix(NA, nrow = nrow(y), ncol = nrow(y))
# Asignar nombres o índices de los nodos a las filas y columnas de x1
rownames(x2) <- rownames(y)
colnames(x2) <- colnames(y)
# Llenar la matriz x1 con la similitud entre los grados normalizados de los nodos
for (i in 1:nrow(y)) {
for (j in 1:nrow(y)) {
x2[i, j] <- 1 - abs(bet[i] - bet[j])
}
}
# Estimar la regresión QAP con la función netlogit. Debido a que son varios nodos, reduciremos la cantidad de repeticiones a realizar.
qap_fit <-netlogit(y,list(x1,x2),rep = 10)
View(nodos)
View(nodos)
# Ver los resultados esperados al finalizar las matrices calculadas
summary(qap_fit)
library(ISLR)
library(tidyverse)
library(Hmisc)
library(sna)
library(igraph)
library(network)
library(readr)
#Vamos a empezar creando una matriz de 50 nodos con valores aleatorios
random_matrix<-matrix(runif(50*50,0,1),50,50)
#Para recrear una matriz, vamos a utilizar la función rgraph del paquete sna.
#Esta función genera matrices a partir de una distribución Bernoulli.
#Para esto vamos a utilizar la matriz de valores aleatorios creada anteriormente
y<- rgraph(50,1,random_matrix) #esto podría generar arcos de un nodo con si mismo
#Corrijamos el problema de los arcos de nodos consigo mismo
for( i in 1:50){
y[i,i]<-0
}
# Crear variable artificial dicotómica relacionada al sexo
x1_array<-rbinom(50,1,0.68) #Esta variable construida con una distribución binomial representa el sexo del nodo, donde el 68% son mujeres.
# Construir la matriz a partir del arreglo. Vamos a utilizar una función llamada delta de Kronecker. Para el caso de una variable dicotómica, calcularemos la función como 1 si ambos nodos tienen el mismo sexo y 0 de lo contrario.
x1<-matrix(0,50,50)
for(i in 1:50){
for(j in 1:50){
if(x1_array[i]==x1_array[j]){
x1[i,j]<-1
}
}
}
# Crear el grafo
grafo <- graph_from_adjacency_matrix(y)
# Calcular el grado total
grado_total <- degree(grafo,mode = "all") #El segundo parámetro de la función sirve para determinar cuál grado calcular. Se puede calcular el grado total (all), de entrada (in) o salida (out)
grado_total <- (grado_total-min(grado_total))/(max(grado_total)-min(grado_total)) #Estandarizar el grado al restarle el mínimo y diviendo entre la resta del máximo y el mínimo
#Ahora aplicamos la misma lógica que con la variable sexo. Solamente que ahora utilizaremos uno menos el valor absoluto de la diferencia.
x2 <- matrix(NA,50,50)
for(i in 1:50){
for(j in 1:50){
x2[i,j]<-1-abs(grado_total[i]-grado_total[j])
}
}
rm(random_matrix,grado_total,i,j,x1_array,grafo)
# Estimar la regresión QAP con la función netlogit
qap_fit <-netlogit(y,list(x1,x2), rep = 10) #El primer parámetro que requiere la función es la variable y, el segundo parámetro es una lista de las covariables y el tercero importante es el parámetro de repeticiones que sirve para entender las instancias para la estimación.
# Ver los resultados
summary(qap_fit)
exp(coef(qap_fit))
arcos <- read_table2("email-Eu-core.txt", col_names = FALSE)
colnames(arcos)<-c("Source","Target")
nodos <- read_table2("email-Eu-core-department-labels.txt",col_names = FALSE)
colnames(nodos)<-c("Id","Departamento")
# Corregir el id 0 sumando 1 unidad a todos los ids
arcos$Source<-arcos$Source+1
arcos$Target<-arcos$Target+1
nodos$Id<-nodos$Id+1
# Crear el grafo
grafo <- graph_from_edgelist(as.matrix(arcos))
# Crear la matriz de adyacencia para la variable y
y<- as.matrix(as_adjacency_matrix(grafo))
# Crear x1 asociado al grado total
grado_total <- degree(grafo,mode = "all")
grado_total <- (grado_total-min(grado_total))/(max(grado_total)-min(grado_total))
x1 <- matrix(NA,nrow(nodos),nrow(nodos))
for(i in 1:nrow(nodos)){
for(j in 1:nrow(nodos)){
x1[i,j]<-1- abs(grado_total[i]-grado_total[j])
}
}
# Coloque aquí las líneas de código para crear la matriz x2 asociada al betweenness
bet <- betweenness(grafo)
bet <- (bet-min(bet))/(max(bet)-min(bet))
x2 <- matrix(NA,nrow(nodos),nrow(nodos))
for(i in 1:nrow(nodos)){
for(j in 1:nrow(nodos)){
x2[i,j]<-1-abs(bet[i]-bet[j])
}
}
# Coloque aquí las líneas de código para crear la matriz x3 asociada al departamento
x3<-matrix(0,nrow(nodos),nrow(nodos))
for(i in 1:nrow(nodos)){
for(j in 1:nrow(nodos)){
if(nodos$Departamento[i]==nodos$Departamento[j]){
x3[i,j]<-1
}
}
}
rm(bet,i,j,grafo,grado_total,arcos, nodos)
# Estimar la regresión QAP con la función netlogit. Debido a que son varios nodos, reduciremos la cantidad de repeticiones a realizar.
qap_fit <-netlogit(y,list(x1,x2,x3),rep = 50)
pr <- pr(n_grafo)
pr <- page_rank(n_grafo)$vector
pr <- (pr-min(pr))/(max(pr)-min(pr))
x3 <- matrix(NA, nrow = nrow(y), ncol = nrow(y))
# Asignar nombres o índices de los nodos a las filas y columnas de x1
rownames(x2) <- rownames(y)
# Asignar nombres o índices de los nodos a las filas y columnas de x1
rownames(x3) <- rownames(y)
colnames(x3) <- colnames(y)
# Llenar la matriz x1 con la similitud entre los grados normalizados de los nodos
for (i in 1:nrow(y)) {
for (j in 1:nrow(y)) {
x3[i, j] <- 1 - abs(pr[i] - pr[j])
}
}
# Estimar la regresión QAP con la función netlogit. Debido a que son varios nodos, reduciremos la cantidad de repeticiones a realizar.
qap_fit <-netlogit(y,list(x1,x2,x3),rep = 10)
# Estimar la regresión QAP con la función netlogit. Debido a que son varios nodos, reduciremos la cantidad de repeticiones a realizar.
qap_fit <-netlogit(y,list(x1,x2,x3),rep = 10)
# Ver los resultados esperados al finalizar las matrices calculadas
summary(qap_fit)
library(ISLR)
library(tidyverse)
library(Hmisc)
library(corrplot)
datos<- Smarket
colnames(datos)
describe(datos)
correlaciones <- cor(Smarket[,1:8]) #Calcular las correlaciones entre las variables
corrplot(correlaciones, method="color") #Graficas las correlaciones
modelo_nulo <- glm(Direction~1,family = "binomial",data = datos)
summary(modelo_nulo)
modelo_completo <- glm(Direction~Lag1+Lag2+Lag3+Lag4+Lag5+Volume,family = "binomial",data = datos)
summary(modelo_completo)
exp(coef(modelo_completo))
View(datos)
View(datos)
# Cargando los datos de arcos y nodos
ubicacion_edges<-"Arcos.xlsx"
arcos<-read_excel(ubicacion_edges)
colnames(arcos)<-c("from","to")
nodos_file <-"Nodos.xlsx"
nodos <- read_excel(nodos_file)
arcos <- arcos[!is.na(arcos$from), ]
nodos <- nodos %>%
filter(Id %in% arcos$from)
arcos <- arcos %>%
filter(to %in% nodos$Id & from %in% nodos$Id)
n_grafo <- graph_from_edgelist(as.matrix(arcos))
numero_nodos <- vcount(n_grafo)
numero_arcos <- ecount(n_grafo)
print(paste("Número de nodos:", numero_nodos))
print(paste("Número de arcos:", numero_arcos))
View(nodos)
#Escriba su código aquí
modelo_completo <- glm(Number of Investments~Number of Investors,family = "binomial",data = nodos)
#Escriba su código aquí
modelo_completo <- glm(`Number of Investments`~`Number of Investors`,family = "binomial",data = nodos)
